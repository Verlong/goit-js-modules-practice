{"mappings":"AACiC,IAA7BA,QAAU,CACZC,KAAMC,SAASC,cAAc,gBAE2CC,WAA5D,MAEqCC,UAAtC,IAKTC,SAAW,SAACC,EAASC,GACvBD,EAAQE,SAAQ,SAAAC,G,KAadF,SAAW,IAAIG,qBAAqBL,UAQpCM,OAASV,SAASW,iBAAiB,OACvCD,OAAOH,SAAQ,SAAAK,G,OAAON,SAASO,QAAQD,E","sources":["src/partials/10.2.2/obsorver.js"],"sourcesContent":["// Налаштування, необов'язковий параметр\nlet options = {\n  root: document.querySelector('.scroll-list'),\n  // root - елемент, який виступає в ролі області перегляду для target (предок цільового елемента або null для viewport)\n  rootMargin: '5px',\n  // rootMargin - відступи навколо root (margin у CSS, за умовчанням всі відступи дорівнюють 0)\n  threshold: 0.5,\n  // threshold - число або масив чисел, що вказує допустимий відсоток перетину target та root\n};\n\n// Функція зворотного виклику. Виклик callback повертає об'єкт, що містить запис про зміни, що відбулися з цільовим елементом:\nlet callback = (entries, observer) => {\n  entries.forEach(entry => {\n    // entry - те, що змінюєтьс, наш цільовий елемент, на який був повішений спостерігач\n    //   entry.boundingClientRect\n    //   entry.intersectionRatio\n    //   entry.intersectionRect\n    //   entry.isIntersecting\n    //   entry.rootBounds\n    //   entry.target\n    //   entry.time\n  });\n};\n\n// Спостерігач 1.\nlet observer = new IntersectionObserver(callback);\n\n// Далі знаходимо цільовий елемент, за яким спостерігатиме спостерігач:\n// Variant 1\n// let target = document.querySelector('.list-item');\n// observer.observe(target);\n\n// Variant 2\nlet images = document.querySelectorAll('img');\nimages.forEach(img => observer.observe(img));\n\n// Вішаємо спостерігача на той цільовий елемент який знайшли раніше\n\n// DOCS: https://developer.mozilla.org/ru/docs/Web/API/Intersection_Observer_API\n"],"names":["options","root","document","querySelector","rootMargin","threshold","callback","entries","observer","forEach","entry","IntersectionObserver","images","querySelectorAll","img","observe"],"version":3,"file":"infinite-scroll-10.2.2.a91c4f5f.js.map"}