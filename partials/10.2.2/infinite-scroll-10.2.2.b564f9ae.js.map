{"mappings":"AAEQA,SAASC,cAAc,gBADE,IAwB7BC,EAAW,IAAIC,sBAdJ,CAACC,EAASC,KACvBD,EAAQE,SAAQC,IAAA,GASd,IAYSP,SAASQ,iBAAiB,OAChCF,SAAQG,GAAOP,EAASQ,QAAQD","sources":["src/partials/10.2.2/obsorver.js"],"sourcesContent":["// Налаштування, необов'язковий параметр\nlet options = {\n  root: document.querySelector('.scroll-list'),\n  // root - елемент, який виступає в ролі області перегляду для target (предок цільового елемента або null для viewport)\n  rootMargin: '5px',\n  // rootMargin - відступи навколо root (margin у CSS, за умовчанням всі відступи дорівнюють 0)\n  threshold: 0.5,\n  // threshold - число або масив чисел, що вказує допустимий відсоток перетину target та root\n};\n\n// Функція зворотного виклику. Виклик callback повертає об'єкт, що містить запис про зміни, що відбулися з цільовим елементом:\nlet callback = (entries, observer) => {\n  entries.forEach(entry => {\n    // entry - те, що змінюєтьс, наш цільовий елемент, на який був повішений спостерігач\n    //   entry.boundingClientRect\n    //   entry.intersectionRatio\n    //   entry.intersectionRect\n    //   entry.isIntersecting\n    //   entry.rootBounds\n    //   entry.target\n    //   entry.time\n  });\n};\n\n// Спостерігач 1.\nlet observer = new IntersectionObserver(callback);\n\n// Далі знаходимо цільовий елемент, за яким спостерігатиме спостерігач:\n// Variant 1\n// let target = document.querySelector('.list-item');\n// observer.observe(target);\n\n// Variant 2\nlet images = document.querySelectorAll('img');\nimages.forEach(img => observer.observe(img));\n\n// Вішаємо спостерігача на той цільовий елемент який знайшли раніше\n\n// DOCS: https://developer.mozilla.org/ru/docs/Web/API/Intersection_Observer_API\n"],"names":["document","querySelector","$b048a3ad2b718214$var$observer","IntersectionObserver","entries","observer","forEach","entry","querySelectorAll","img","observe"],"version":3,"file":"infinite-scroll-10.2.2.b564f9ae.js.map"}